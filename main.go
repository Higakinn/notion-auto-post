
// package main

// import (
// 	"fmt"
// 	"strings"
// 	"net/http"
// 	"io/ioutil"
// 	// "bytes"
// 	"time"
// )
package main


import (
	"fmt"
	// "strings"
	// "net/http"
	// "encoding/json"
	// "io/ioutil"
	"time"

	"github.com/higakinn/notion-auto-post/infrastructure/notion"
	
)

type AutoGenerated struct {
	Object  string `json:"object"`
	Results []struct {
		Object         string    `json:"object"`
		ID             string    `json:"id"`
		CreatedTime    time.Time `json:"created_time"`
		LastEditedTime time.Time `json:"last_edited_time"`
		CreatedBy      struct {
			Object string `json:"object"`
			ID     string `json:"id"`
		} `json:"created_by"`
		LastEditedBy struct {
			Object string `json:"object"`
			ID     string `json:"id"`
		} `json:"last_edited_by"`
		Cover  interface{} `json:"cover"`
		Icon   interface{} `json:"icon"`
		Parent struct {
			Type       string `json:"type"`
			DatabaseID string `json:"database_id"`
		} `json:"parent"`
		Archived   bool `json:"archived"`
		Properties struct {
			Tags struct {
				ID       string        `json:"id"`
				Type     string        `json:"type"`
				Relation []interface{} `json:"relation"`
			} `json:"Tags"`
			Status struct {
				ID     string      `json:"id"`
				Type   string      `json:"type"`
				Select interface{} `json:"select"`
			} `json:"status"`
			Name struct {
				ID    string `json:"id"`
				Type  string `json:"type"`
				Title []struct {
					Type string `json:"type"`
					Text struct {
						Content string      `json:"content"`
						Link    interface{} `json:"link"`
					} `json:"text"`
					Annotations struct {
						Bold          bool   `json:"bold"`
						Italic        bool   `json:"italic"`
						Strikethrough bool   `json:"strikethrough"`
						Underline     bool   `json:"underline"`
						Code          bool   `json:"code"`
						Color         string `json:"color"`
					} `json:"annotations"`
					PlainText string      `json:"plain_text"`
					Href      interface{} `json:"href"`
				} `json:"title"`
			} `json:"Name"`
			Date struct {
				ID   string `json:"id"`
				Type string `json:"type"`
				Date struct {
					Start    string      `json:"start"`
					End      interface{} `json:"end"`
					TimeZone interface{} `json:"time_zone"`
				} `json:"date"`
			} `json:"Date"`
			URL struct {
				ID   string `json:"id"`
				Type string `json:"type"`
				URL  string `json:"url"`
			} `json:"URL"`
		} `json:"properties"`
		URL string `json:"url"`
	} `json:"results"`
	NextCursor string `json:"next_cursor"`
	HasMore    bool   `json:"has_more"`
	Type       string `json:"type"`
	Page       struct {
	} `json:"page"`
}

// // https://mholt.github.io/json-to-go/
// func main() {
// 	url := fmt.Sprintf("https://api.notion.com/v1/databases/%s/query", "")

// 	payload := strings.NewReader("{\"page_size\":2}")

// 	req, _ := http.NewRequest("POST", url, payload)
  
// 	req.Header.Add("Authorization", "Bearer " + "")
// 	req.Header.Add("Accept", "application/json")
// 	req.Header.Add("Notion-Version", "2022-02-22")
// 	req.Header.Add("Content-Type", "application/json")

// 	res, _ := http.DefaultClient.Do(req)

// 	defer res.Body.Close()
// 	body, _ := ioutil.ReadAll(res.Body)
// 	// if err != nil {
// 		// 	log.Fatal(err)
// 		// }
		
// 		fmt.Println(res)
// 		fmt.Println(string(body))
// 	// var out bytes.Buffer
// 	// json.Indent(&out, body, "", "  ")
// 	// // out.WriteTo(os.Stdout)
// 	// var a AutoGenerated
// 	// err := json.Unmarshal(body, &a)
// 	// if err != nil {
// 	// 	// エラー処理
// 	// }

// 	// // fmt.Println(a)
// 	// for k, v := range a.Results{
// 	// 	fmt.Println(k, v.Properties.NAMING_FAILED.Title[0].Text)
// 	// }
// }

	
func main() {
	r := notion.NewItemRepository()
	ds, _ := r.FindAll()
	fmt.Println(ds)
  // dbId := os.Getenv("NOTION_DATABASE_ID")
	// nToken := os.Getenv("NOTION_ACCESS_TOKEN")
	// qToken := os.Getenv("QIITA_ACCESS_TOKEN")
  
	// nClient := input.NewNotionClient(nToken)
	// qClient := output.NewQiitaClient(qToken)

	// a, _ := nClient.QueryDatabases(dbId)

	// qArticleId := os.Getenv("QIITA_ARTICLE_ID")
	// title := "テスト"
  // qBody := ""
	// for _,v := range a.Results {
	// 	nTitle := v.Properties.Name.Title[0].Text.Content
	// 	nUrl := v.Properties.URL.URL
	// 	qBody += "## " + nTitle + "\n\n" + nUrl + "\n\n"
	// }
	// tags := []output.QiitaTag{ {"Qiita", [] string{}} }

	// if err := qClient.UpdateItem(qArticleId, title, qBody, tags); err != nil {
	// 	// return errors.WithStack(err)
	// }
}